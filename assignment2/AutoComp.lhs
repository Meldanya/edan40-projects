EDAN40 Project 2
HT2 2013

Tommy Olofsson        ada09tol@student.lu.se
Erik Jansson          ada09eja@student.lu.se

-----------------------------------------------------------------

Introduction
============

This Haskell module implements functionality which is used to automatically
generate chord and bass lines for songs given a melody and a chord progression
for that melody. We will explain much of the theory but rudimentary
understanding of music theory will certainly aid the reader when trying to
understand this report.

> module AutoComp where

We begin by importing some modules we need:

> import Haskore hiding (Key) -- We have our own definition of Key
> import Data.Ratio           -- Needed to be able to define duration ratios


Basics
======

Somewhat simplified, music is fundamentally made up of notes played in
succession and/or in parallel. Each note is defined by a pitch class and an
octave. Each octave contains 12 pitch classes (as can easily be seen on regular
piano):

    C, Cs/Df, D, Ds/Ef, E, F, Fs/Gf, G, Gs/Af, A, As/Bf, B

The combination of pitch class and octave uniquely identifies which frequency
the note corresponds to. A musical score also defines how long the note should
be played, called the duration. There are e.g. whole notes, half notes and
quarter notes. A musical piece is divided into several bars of some duration
(typically 4 quarter notes long).

We use the Haskore library for generating the sound. Haskore defines many of the
types used in this module (e.g. PitchClass, Mode, Pitch, Dur) so here is a short
description of the important ones:

    * PitchClass - Haskore's definition of a pitch class (desrcibed above).
    * Mode       - Major or Minor
    * Pitch      - Haskore's way of representing a note, i.e. a pitch class and
                    an octave.
    * Dur        - A Haskore type representing a duration in fractions of a bar.
    * Music      - Haskore's representation of music, it is quite an extensive
                   type which is out of the scope of this report.

Each song has a key which is defined by a PitchClass (called a root note) and a
Mode (called a harmonic quality), e.g. (C, Major). The key of the song gives the
scale from which chords and the bass line can be built.

This is where we define our own Key type that better suits our code:

> type Key = (PitchClass, Mode)

For simplicity's sake, we also define a list with all available notes in an
octave. This will be quite useful later on.

> notes = [C, Cs, D, Ds, E, F, Fs, G, Gs, A, As, B]

Chord types
-----------

A chord is made up of notes played simultaneously. In our case, we use the basic
triad chord which means that each chord generated by this module will consist of
three notes. Such a chord is represented by our Triad data type:

> type Triad = [Pitch]

Recall that the type Pitch is Haskore's representation of a note, i.e. a pitch
class and an octave. Our Triad type is thus simply a list of (three) notes.

Somewhat confusingly, it will hopefully be clearer soon, we define a
ChordProgression type (i.e. a sequence of chords) which does not use the same
chord type (Triad).

> type ChordProgression = [(PitchClass, Dur)]

The ChordProgression type is a list of tuples with a PitchClass and a Dur, which
represents the root of the chord and how long the chord should be played.

The reason this type doesn't use the Triad type is that this is the type of one
of the inputs to the autoComp function. This is how the chord progression from
the score should be coded for the autoComp function to understand it. From the
score, it is easy to read which chord should be played next and for how long.
This is what is encoded into a ChordProgression.

It should be easy to understand with an example. If we have the chord
progression:

     C                F       C
    |----------------|----------------|

This should be encoded as:

    > chordProg = [(C, 1), (F, (1%2)), (C, (1%2))]

Bass types
----------

The autoComp function will also generate a bass line so we need to define data
types for this. We begin with the BassStyle type which represents (as the name
implies) different styles of bass lines:

> type BassStyle = [(Int, Dur)] -- Scale offset (if > 0 else rest), length.

We will soon define three different bass styles based on this type which will
make it clear why it is defined as it is. Briefly, a bass style is a list of
"notes" (not the same as Haskore's Pitch type) with an offset from the base of
the scale and a duration. A rest (i.e. no sound) is defined as having an offset
of -1.

Now let's define the three bass styles we support; basic, calypso and boogie:

> basic, calypso, boogie :: BassStyle
> basic = [(0, hn), (4, hn)]
> calypso = concat [h, h] where h = [(-1, qn), (0, en), (2, en)]
> boogie = concat [h, h] where h = [(0, en), (4, en), (5, en), (4, en)]

As one might read from their definition, each style is defined over a bar (4
quarter notes long):

    * basic is two half notes, one with offset 0 and one with offset 4 (i.e. the
      first and fifth note in the scale.
    * calypso is a pause for one quarter note, then two eighth notes (first and
      third note). This is repeated twice.
    * boogie is a pattern of four eighth notes repeated twice.


Bass Line
=========

An important part of a song is the bass line which provides structure to the
song. In our implementation, the autoBass function will generate that bass line
from a BassStyle, a Key and a ChordProgression. The BassStyle defines how the
bass notes should be played, and together with the key it also specifies how to
choose notes from a chord.

> autoBass :: BassStyle -> Key -> ChordProgression -> Music
> autoBass bs key cp = zipBass cp (cycle bs) key

The zipBass function aligns the bass beat with the main song in order to select
the bass notes according to the current playing chord. Using this solution, the
song can contain an arbitrary number of chords per bar.

> zipBass :: ChordProgression -> BassStyle -> Key -> Music
> zipBass [] _ _ = Rest (0%4)     -- TODO: fugly
> zipBass chords@((c0, cdur): cr)
>         style@((s0, sdur): sr)
>         key
>
>         | cdur == 0 = zipBass cr style key
>         | sdur == 0 = zipBass chords sr key
>         | otherwise = passProc c0 s0 key dur :+: zipBass ((c0, cdur - dur):cr) ((s0, sdur - dur):sr) key
>         where dur = min sdur cdur

passProc uses the key and the offset specified in the bassStyle to index the
scale and raise the root note of a chord a number of semitones.

In other words:

    * The PitchClass gives the root note (of a chord), this is arbitrarily
      placed in the 3:rd octave.
    * The Int, (from bassStyle) then specifies how many steps up the scale the
      note should be.
    * The Key, along with magicTable, gives this difference in pitch in
      semitones.

> passProc :: PitchClass -> Int -> Key -> Dur -> Music
> passProc _ (-1) _ dur = Rest dur
> passProc pc soff key dur = Note newPitch dur [Volume 10]
>     where newPitch = pitch ((absPitch (pc, 3)) + ((magicTable key) !! soff))

magicTable contains the scales as differences in semitones.

> magicTable :: Key -> [Int]
> magicTable (C, Major) = [0, 2, 4, 5, 7, 9, 11] -- Ionian
> magicTable (C, Minor) = []
> magicTable (D, Major) = [0, 2, 4, 5, 7, 9, 10] -- Mixolydian
> magicTable (D, Minor) = [0, 2, 3, 5, 7, 9, 10] -- Dorian
> magicTable (E, Major) = []
> magicTable (E, Minor) = [0, 1, 3, 5, 7, 8, 10] -- Phrygian
> magicTable (F, Major) = [0, 2, 4, 6, 7, 9, 11] -- Lydian
> magicTable (F, Minor) = []
> magicTable (G, Major) = [0, 2, 4, 5, 7, 9, 10] -- Mixolydian
> magicTable (G, Minor) = []
> magicTable (A, Major) = []
> magicTable (A, Minor) = [0, 2, 3, 5, 7, 8, 10] -- Aeolian


Chord Line
==========

The types and most of the theory has been explained above so autoChord should be
fairly straight forward. The autoChord function takes a Key and a
ChordProgression and returns a Haskore Music object which is the chord line it
has produced.

> autoChord :: Key -> ChordProgression -> Music
> autoChord key (c:cs) = firstChord :+: zipChord chordTriad cs key
>     where (c1,c3,c5) = getChord key $ fst c -- First chord, without octave
>           chordTriad = [(c1,4), (c3,4), (c5,4)] -- First chord is octave 4
>           firstChord = chordToHask chordTriad $ snd c -- Haskore chord

In order to do its job, it generates the first chord manually (bootstrapping)
and then calls zipChord to generate the rest of the chord line. zipChord takes a
Triad representing the previous chord, a ChordProgression which it should
generate a chord line for and the Key of the song. It returns a Haskore Music
object which it has constructed recursively.

> zipChord :: Triad -> ChordProgression -> Key -> Music
> zipChord _ [] _ = Rest 0
> zipChord prev (c:cs) key = chord :+: zipChord chordList cs key
>    where
>       chordList = pickChord prev (c:cs) key 
>       chord = chordToHask chordList $ snd c

zipChord uses the pickChord function which takes a previous chord, the
chord progression and the key and picks the "optimal" chord for the song.
Optimal is a bit of a misnomer since all it does is uses some predetermined
rules to pick a chord. These rules are:

    1. The difference between the corresponding notes in the previous chord and
       this chord should be as small as possible.
    2. The notes within a chord should be as close to each other as possible.
    3. The notes of a chord should lie within E,4 and G,5 (i.e. above E in
       octave 4 and below G in octave 5).

The triad pattern we use for chords only specify which notes should be part of
the chord, it doesn't limit in which octaves these lie. In order to pick the
optimal chord, pickChord generates a list of all possible octave combinations of
a chord and then applies the rules above to this list.

> pickChord :: Triad -> ChordProgression -> Key -> Triad
> pickChord prev (c:cs) key = chord
>    where
>        (ch:chs) = generateChords (fst c) key -- All possible chords
>        filteredChords = filter (filterChords) chs -- Chords conforming to rule 3
>        chord = foldr (optimizeChord prev) ch filteredChords -- The "optimum" chord

> generateChords :: PitchClass -> Key -> [Triad]
> generateChords c k = chords
>    where
>        chords = [ [(c1, o1), (c3, o2), (c5, o3)] | o1 <- [1..12], o2 <- [1..12], o3 <- [1..12] ]
>        (c1, c3, c5) = getChord k c

The getChord function take a Key and a PitchClass and return a 3-tuple with the
three PitchClasses that makes up the chord. Note: It does not bother with which
octave the chord is in, this is handled by the combination of generateChords and
pickChord.

> getChord :: Key -> PitchClass -> (PitchClass,PitchClass,PitchClass)
> getChord key pc = (pc,c3,c5)
>    where
>         c3 = filteredScale !! (3-1)
>         c5 = filteredScale !! (5-1)
>         filteredScale = map (infNotes !!) scale
>         scale = magicTable key
>         infNotes = take 12 . dropWhile (/=pc) $ cycle notes

The first rule applied in pickChord is the third one. It is applied by use of
the filterChords function which returns True if all notes in a chord lies within
the boundary set by rule three.

> filterChords :: Triad -> Bool
> filterChords chord = all (\c -> absPitch c > lowerBound && absPitch c < upperBound) chord
>     where lowerBound = absPitch (E,4)
>           upperBound = absPitch (G,5)

In order to apply rule one and two, the optimizeChord function is used to
combine the two rules into a weighted score for two chords. The chord with the
lowest score is considered to be the optimum one.

> optimizeChord :: Triad -> Triad -> Triad -> Triad
> optimizeChord prev c1 c2
>     | score1 < score2 = c1
>     | otherwise       = c2
>     where dist1 = chordDist prev c1
>           dist2 = chordDist prev c2
>           inDist1 = noteDist c1
>           inDist2 = noteDist c2
>           score1 = 0.5 * fromIntegral dist1 + 0.5 * fromIntegral inDist1
>           score2 = 0.5 * fromIntegral dist2 + 0.5 * fromIntegral inDist2

> chordDist :: Triad -> Triad -> Int -- Rule one
> chordDist [c1, c2, c3] [d1, d2, d3] = foldr1 (+) $ map abs [ac1-ad1, ac2-ad2, ac3-ad3]
>     where ac1 = absPitch c1
>           ac2 = absPitch c2
>           ac3 = absPitch c3
>           ad1 = absPitch d1
>           ad2 = absPitch d2
>           ad3 = absPitch d3

> noteDist :: Triad -> Int -- Rule two
> noteDist [c1, c2, c3] = maximum $ map abs [ac1-ac2, ac1-ac3, ac2-ac3]
>     where ac1 = absPitch c1
>           ac2 = absPitch c2
>           ac3 = absPitch c3

Our representation of a chord is somewhat different from Haskore's so in order
to simplify conversion, we implement a function that converts a chord in Triad
form and a duration for that chord into the chord Haskore understands.

> chordToHask :: Triad -> Dur -> Music
> chordToHask pitches dur = foldr1 (:=:) [ Note c dur [Volume 70] | c <- pitches ]


Combining It All
================

The only thing left now that we have generated chord and bass line is to combine
it into a Haskore Music object which will play both simultaneously. Playing
something simultaneously is done with the :=: operator. Thus, we simply need to
call the autoBass and autoChord functions and concatenate their results with the
:=: operator to get a nice accompaniment for the song.

> autoComp :: BassStyle -> Key -> ChordProgression -> Music
> autoComp style key prog = (Instr "bass" $ autoBass style key prog) :=: autoChord key prog

